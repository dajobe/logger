#!/usr/bin/perl -w
#
# IRC chat logger
#
# $Source$
# $Id$
#
# (C) Copyright 2000 Dave Beckett, ILRT, University of Bristol
# http://www.ilrt.bristol.ac.uk/people/cmdjb/
#

use strict;

# Come with Perl
use File::Path;
use File::Basename;

use Sys::Hostname;

# CPAN
use URI;
use Net::IRC;


%ENV=();
$ENV{PATH}='/bin:/usr/bin:/usr/local/bin';


# Global constants
$::program=basename $0;

$::Host=(hostname || 'unknown');

$::Nick='logger'; # OK this can be changed if clashes
$::IRC_Name='Chat Logger';
$::Max_Results=5;
$::Max_Max_Results=20;


# Global variables

# IRC object
$::IRC=undef;

# root dir of logs
$::Log_Root='';

# place on the web this corresponds to
$::Log_URI='';

# System password
$::Password='';

# Print welcome message?
$::Do_Welcome=0;

# True if leaving (so don't reconnect)
$::Departing=0;

# True if connecting (don't log server notices)
$::Connecting=0;


# Global Variables that should be per-Channel
# title
%::Config=();

$::Channel_Title='';

# irc:: URI
$::Channel_URI='';

# topic of channel
$::Channel_Topic='';

# Last ID seen
$::Channel_Last_ID='';

# True if logging
$::Channel_Listening=0;




######################################################################
package URI::irc;

# http://www.w3.org/Addressing/draft-mirashi-url-irc-01.txt
# irc:[ //[ <host>[:<port>] ]/[<target>] [,needpass] ]

require URI::_server;

@URI::irc::ISA=qw(URI::_server);

sub default_port { 6667 }

sub channel ($) {
  my $path=shift->path;
  if($path && $path =~ m%^/([^/]+)%) {
    return $1;
  }
  undef;
}

package main;

######################################################################


sub main {

  die "Usage: $::program password channel-URI channel-title log-dir log-URI\n  where channel-URI is like irc://host[:port]/channel,isnick,needpass"
    unless @ARGV==5;
  my($password,$uri_string,$channel_title, $log_root, $log_uri_string)=@ARGV;

  my $uri;
  eval '$uri=new URI $uri_string';
  die "$::program: '$::Channel_URI' does not look like an IRC URI\n" 
    if ($@ || !$uri);


  die "$::program: log dir $log_root does not exist\n" unless -d $log_root;

  # Set globals
  $::Password=$password;
  $::Log_Root=$log_root;
  $::Log_URI=$log_uri_string;
  $::Do_Welcome=0;
  $::Departing=0;
  $::Connecting=1;

  # FIXME - pid_file should not have channel in it, when logger
  # handles multiple channels
  my $pid_file=$::Log_Root.'/logger-'.$uri->channel.'.pid';
  open(PID,">$pid_file");
  print PID "$$\n";
  close(PID);

  $::IRC = new Net::IRC;

  join_channel($uri, $channel_title);

  # Never returns
  $::IRC->start;
}

&main;

exit 0;


######################################################################
# Logging

sub log_event ($$$;$) {
  my($self, $event, $t, $msg)=@_;
  my $nick=$event->nick;

  return if !$::Channel_Listening;

  my $uri=$::Channel_URI;

  my $channel=$uri->channel;
  my $log_dir=log_dir_for_channel($uri);

  mkpath([$log_dir], 0, 0755) if ! -d $log_dir;
  # Failed!
  if (! -d $log_dir) {
    $self->privmsg("#$channel", "failed to create chat log dir, quitting");
    exit(0);
  }

  my @tm = gmtime($t);
  $tm[5]+= 1900; $tm[4]++;
  my $date = sprintf("%04d-%02d-%02d", $tm[5], $tm[4], $tm[3]);
  my $time = sprintf("%02d:%02d:%02d", $tm[2], $tm[1], $tm[0]);
  my $date_time="$date $time";

  my $log_file = "$log_dir/$date.txt";
  my $rdf_log_file = "$log_dir/$date.rdf";

  my $rdf_suffix="    </rdf:Seq>\n  </foaf:chatEventList>\n</foaf:ChatChannel>\n</rdf:RDF>\n";


  # Failed!
  if (!open(LOG, ">>$log_file")) {
    $self->privmsg("#$channel", "failed to append to log file, quitting - $!");
    exit(0);
  }
  my $text_msg=$nick ? qq{<$nick> $msg} : $msg;
  print LOG "$time $text_msg\n";
  close(LOG);


  if(!-r $rdf_log_file) {
    if (!open(RLOG, ">$rdf_log_file")) {
      $self->privmsg("#$channel", "failed to append to log file, quitting - $!");
      exit(0);
    }

    print RLOG <<"EOT";
<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:wn="http://xmlns.com/wordnet/1.6/"
         xmlns:foaf="http://xmlns.com/foaf/0.1/">
<foaf:ChatChannel rdf:about="$::Channel_URI">
  <foaf:chatEventList>
    <rdf:Seq>
EOT
  } else {
    if (!open(RLOG, "+<$rdf_log_file")) {
      $self->privmsg("#$channel", "failed to append to log file, quitting - $!");
      exit(0);
    }

    # seek back
    seek(RLOG, -length($rdf_suffix), 2) # 2= SEEK_END
  }

  # Make a legal XML id from the time
  my $ID="T$time"; $ID =~ s/:/-/g;

  # add a unique suffix if necessary
  if(length($::Channel_Last_ID) != length($ID)) {
    # If last ID was in same second, need to start from next
    # ID HH-MM-SS-X and increment X
    # otherwise, new ID is OK
    if ($::Channel_Last_ID =~ /^$ID-(\d+)$/) {
      $ID.="-".$1+1;
    }
  } elsif($ID eq $::Channel_Last_ID) {
    # Else if was same as last ID, must be first duplicate of this
    # ID in this time slot ie last id was HH-MM-SS so add -1 to make 
    # it unique HH-MM-SS-1
    $ID.="-1";
  }
  $::Channel_Last_ID=$ID;


  print RLOG <<"EOT";
      <rdf:li rdf:ID="$ID"><foaf:chatEvent>
        <dc:date>${date}T${time}Z</dc:date>
EOT
  print RLOG qq{        <dc:description>}.xml_escape($msg).qq{</dc:description>\n};
  print RLOG qq{        <dc:creator><wn:Person foaf:nick="$nick"/></dc:creator>\n} if $nick;
  print RLOG qq{      </foaf:chatEvent></rdf:li>\n};
  print RLOG $rdf_suffix;

  close(RLOG);
}


sub log_dir_for_channel ($) {
  my $uri=shift;

  my $channel=$uri->channel; $channel=~ s/\W//g;

  return $::Log_Root.'/'.$uri->host.':'.$uri->port.'/'.$channel.'/';
}


sub get_logs ($$) {
  my($self,$uri)=@_;

  my $log_dir=log_dir_for_channel($uri);

  return () if !opendir(DIR, $log_dir);

  # In date order, newest lines at top
  my(@results)=();
  # Newest files first
  for my $file (reverse sort readdir(DIR)) {
    next unless $file =~ /^(\d\d\d\d-\d\d-\d\d).txt/;
    my $date=$1;
    open(LOG, "$log_dir/$file") or next;
    
    # Append to list, reverse date sorted list - i.e. older entries at end 
    my(@lines);
    while(<LOG>) {
      chomp;
      # Ignore logger's own output
      next if m%^\d\d:\d\d:\d\d <$::Nick>%;
      push(@lines, "$date $_") if length $_;
    };
    close(LOG);
    push(@results, reverse @lines);
  }
  closedir(DIR);

  return(@results);
}


######################################################################
# Global events

# What to do when logger successfully connects.
sub on_connect {
  my ($self, $event) = @_;
  
  my $channel='#' . $::Channel_URI->channel;

  $self->join($channel);
  $::Channel_Listening=1;
  $self->me($channel, 'is logging');
}


# What to do when logger's nick is already used
sub on_nicknameinuse {
  my ($self, $event) = @_;
  
  if ($::Nick !~ /_/) {
    $::Nick.="_1";
  } else {
    $::Nick++; # magical increment
  }
  $self->nick($::Nick);
}


# Prints the names of people in a channel when we enter.
sub on_names {
  my ($self, $event) = @_;
  my (@list, $channel) = ($event->args);
  
  # splice() only works on real arrays. Sigh.
  ($channel, @list) = splice @list, 2;
  
  log_event($self, $event, time, "Users on $channel: @list");

  $::Connecting=0;
}


# Reconnect to the server when we die.
sub on_disconnect {
  my ($self, $event) = @_;
  
  log_event($self, $event, time, "Disconnected from ". $event->from(). " (". ($event->args())[0]. ")");

  return if $::Departing;

  log_event($self, $event, time, "Attempting to reconnect");
  exit 0;
}


######################################################################
# Per connection events


# When received a private message
sub on_msg {
  my($self,$event)=@_;
  my $nick = $event->nick;
  my $channel = $event->to;

  return if $nick eq $::Nick;

  my $arg = join(' ', $event->args);
  command_for_me($self, $event, $channel, $arg, 1);
}


# What to do when we receive channel text.
sub on_public {
  my ($self, $event) = @_;
  my @to = $event->to;
  my ($nick, $mynick) = ($event->nick, $self->nick);
  my $arg = join(' ', $event->args);

  # Private stuff
  return if $arg =~ /^\[off\]/i;

  if ($arg =~ /^$mynick,\s+(.*)$/) {
    command_for_me($self, $event, $to[0], $1, 0);
  }

  log_event($self, $event, time, $arg);
}


# What to do when we receive /me (and other stuff??)
sub on_caction {
  my ($self, $event) = @_;
  my $nick = $event->nick;
  my $arg = join(' ', $event->args);

  # Private stuff
  return if $arg =~ /^\[off\]/i;

  log_event($self, $event, time, "* $nick $arg");
}


# What to do when someone leaves a channel logger is on.
sub on_part {
  my ($self, $event) = @_;
  my ($channel) = ($event->to)[0];
  my $nick=$event->nick;

  log_event($self, $event, time, "$nick has left channel");
}


# What to do when we receive channel notice (mostly other bots)
sub on_notice {
  my ($self, $event) = @_;
  my $nick = $event->nick;
  my $arg = join(' ', $event->args);

  # Private stuff
  return if $arg =~ /^\[off\]/i;

  return if $::Connecting;

  log_event($self, $event, time, $arg);
}



# What to do when someone leaves a channel logger is on.
sub on_quit {
  my ($self, $event) = @_;
  my ($channel) = ($event->to)[0];
  my $nick=$event->nick;
  my $arg = join(' ', $event->args);
  log_event($self, $event, time, "$nick has quit ($arg)");
}


# What to do when someone does /nick
sub on_nick {
  my ($self, $event) = @_;
  my ($channel) = ($event->to)[0];
  my $nick=$event->nick;
  my $arg = join(' ', $event->args);
  log_event($self, $event, time, "$nick is now known as $arg");
}

# What to do when someone does /topic MSG
sub on_topic {
  my ($self, $event) = @_;
  my $nick=$event->nick;
  my(@args)=$event->args;
  my $arg;
  if(@args == 3) {
    $arg=$args[2];
    log_event($self, $event, time, "topic is: $arg");
  } else {
    $arg=$args[0];
    log_event($self, $event, time, "$nick has changed the topic to: $arg");
  }
  $::Channel_Topic=$arg;
}


# What to do when someone joins a channel logger is on.
sub on_join {
  my ($self, $event) = @_;
  my ($channel) = ($event->to)[0];
  my $user_nick=$event->nick;
  
  log_event($self, $event, time, sprintf("%s (%s) has joined $channel", $user_nick, $event->userhost));

  return if !$::Do_Welcome;

  my $logging=($::Channel_Listening) ? "logging" : "not logging";

  my(@intro)=(
   "Welcome to the $::Channel_Title",
   "I'm currently $logging to $::Log_URI",
   "For extensive help do: /msg $::Nick help"
  );

  my $do_sleep=0;
  for my $output (@intro) {
   sleep(1) if $do_sleep;
   $self->privmsg($event->nick, $output);
   $do_sleep=1;
  }
}


sub command_for_me ($$$$$) {
  my($self, $event, $channel, $command, $is_private)=@_;
  my $from_nick=$event->nick;

  $command=~s/^\s+//;

  my $output='';

  my $dest_nick=($is_private ? $from_nick : $event->to);

  my $valid_password=0;
  if($command =~ s/^password (\S+)\s*//) {
    if($1 eq $::Password) {
      $valid_password=1;
    } else {
      $self->privmsg($dest_nick, "Invalid password");
      return;
    }
  }

  if($is_private && $valid_password) {

    if($command eq 'restart') {
      $::Departing=1;
      $self->me($event->to, ' is departing');
      $self->quit;
      sleep(1);
      $::Connecting=1;
      $self->connect();
      return;
    }
  
    if($command eq 'debug') {
      $self->privmsg($dest_nick, "Debugging is on");
      $self->debug(1);
      return;
    }
    
    if($command eq 'nodebug') {
      $self->privmsg($dest_nick, "Debugging is off");
      $self->debug(0);
      return;
    }
  }
  
  if($command=~ /^(?:quit|finish|terminate|die die die|exterminate)/i) {
    $::Departing=1;
    $self->me($event->to, 'is departing');
    # Log who told me to quit
    log_event($self, $event, time, "Logger told to quit");
    $self->quit;
    exit 0;
  }
  
  if($command=~ /^(?:be quiet|shut up|silence|sshush|stop|off)/i) {
    if($::Channel_Listening) {
      $self->me($event->to, 'is not logging');
      # Log who turned me off BEFORE turning off logging
      log_event($self, $event, time, "Logging turned off");
      $::Channel_Listening=0;
    } else {
      $self->me($event->to, 'is already not logging');
    }
    return;
  }
  
  if($command=~ /^(?:hello|log|listen|record|start|begin|on)/i) {
    if(!$::Channel_Listening) {
      $self->me($event->to, 'is logging');
      $::Channel_Listening=1;
      # Log who turned me on
      log_event($self, $event, time, "Logging turned on");
    } else {
      $self->me($event->to, 'is already logging');
    }
    return;
  }

  if(!$::Channel_Listening) {
    $output="I'm not logging. ";
  } else {
    $output="I'm logging. ";
  }

  # Allow question?
  if ($command =~ /^(.+)\?$/) {
    $command="grep $1";
  }

  if($command=~ /^help/i) {
    my(@help)=(
      "The commands I know are:",
      "  quit        - I will depart",
      "  silence     - Stop logging (also: stop, off, ...)",
      "  listen      - Start logging (also: start, on, ...)",
      "  grep [-i] [first-last|max] <perl regex>  - Search the logs",
      "    e.g. grep foo, grep 5 bar, grep -i things [case independent]",
      "    append |mail EMAIL-ADDRESS to email results instead of printing",
      "I respond to '$::Nick, command' in public and '/msg $::Nick command' in private",
      "Logging Policy: All public output is logged if I am listening except",
      "for any lines starting [off].   All commands to me are logged.",
      "My public output is logged but these lines are not searchable.",
      "The public logs are at $::Log_URI",
    );
    my $do_sleep=0;
    for my $output (@help) {
      sleep(1) if $do_sleep;
      $self->privmsg($dest_nick, $output);
      $do_sleep=1;
    }
    return;
  }

  if ($command =~ /^(?:grep|search for|find)\s+(.+)$/) {
    my $search=$1;
    my $flags='';
    my($first,$last)=(0,$::Max_Results);

    if($search=~ s/^-i\s+//) {
      $flags='(?i)';
    }

    my $mail='';
    if($search =~ s%\|mail\s+(.+)$%%) {
      $mail=$1;
      $search =~ s%\s+$%%;
    }

    if($search=~ s/^(\d+|\d+-\d+)\s+(?:things about\s+|)//) {
      my $arg=$1;
      if($arg=~ m%^(\d+)-(\d+)$%) {
	($first,$last)=($1,$2);
	# Reset if stupid things done
	if($first > $last) {
	  ($first,$last)=(0,$::Max_Results);
	}
      } else {
        $last=$arg;
      }
    }

    my $orig_search=$search;

    # Only allow a few regexes

    # Remove (?...) blocks since they can do evals
    $search =~ s/\(\?[^)]+\)//g;
    # Remove variable references
    $search =~ s/\$//g;
    # Quote '/'s
    $search =~ s%/%\\/%g;


    # Prefix with flags
    $search=$flags.$search;

    my(@lines)=get_logs($self, $::Channel_URI);

    my(@results);
    eval "\@results=grep(/$search/, \@lines)";
    if($!) {
      @results=();
      my $msg=$!; $msg=~ s/^ at .+$//;
      $output.=qq{ Sorry, search failed with error - $msg};
    } elsif (!@results) {
      $output.=qq{ Sorry, nothing found for '$orig_search'};
      $output.=qq{ (internally: "$search")} if $orig_search ne $search;
    } elsif ($mail) {
      my $userhost=$event->userhost;

      my $pl=(@results != 1) ? 's' : '';
      my $count=scalar(@results);
      if(open(PIPE,"|/usr/lib/sendmail -t")) {
	print PIPE "From: $::IRC_Name\n";
	print PIPE "To: $mail\n";
	print PIPE "Subject: Results of search '$orig_search' on $::Channel_Title\n";
	print PIPE "\n";
	print PIPE "This email is the result of a search by\n";
        print PIPE "nick $from_nick ($userhost) on the\n";
	print PIPE "$::Channel_Title\n";
	print PIPE "This channel is logged at $::Log_URI\n";
	print PIPE "\n";
	print PIPE "$count result$pl follow:\n";
	print PIPE join("\n", reverse @results);
	close(PIPE);
	$output.=qq{ Mailed $count result$pl to $mail};
	log_event($self, $event, time, "Search results from '$orig_search' mailed to $mail");
      } else {
	$output.=qq{ Sorry, failed to mail results to $mail - internal error};
      }
    } else {
      my $pl=(@results != 1) ? 's' : '';
      $output.=" I found ".scalar(@results)." answer$pl for '$orig_search'";
      $last=@results if $last > @results;
      if($first !=0 || $last != @results) {
	$output.=" (showing $first...$last)";
      }
      $self->privmsg($dest_nick, $output);
      log_event($self, $event, time, $output) unless $is_private;

      my $count=0;
      for(my $i=$first; ($i< @results) && ($i <= $last); $i++) {
	sleep(1);
	$output="$i) ".$results[$i];
	$self->privmsg($dest_nick, $output);
	log_event($self, $event, time, $output) unless $is_private;
	$count++;
	last if $count > $::Max_Max_Results;
      }
      return;
    }
  } else {
    $output.="I don't understand '$command', $from_nick.  Try /msg $::Nick help";
  }

  $self->privmsg($dest_nick, $output);
  log_event($self, $event, time, $output) unless $is_private;
}

sub xml_escape ($) {
  my $string=shift;
  $string =~ s/\&/\&amp;/g;
  $string =~ s/</\&lt;/g;
  $string =~ s/>/\&gt;/g;
  $string =~ s/[\x00-\x1F]//g;  # remove ASCII 0-31
  $string =~ s/([\x80-\xFF])/"\&#".ord($1).";"/ge; # escape ASCII 128-255
  $string;
}


sub join_channel($$) {
  my($uri, $title)=@_;

  my $channel=$uri->channel;
  $::Config{$channel}->{URI}=$uri;
  $::Config{$channel}->{Title}=$title;
  $::Config{$channel}->{Listening}=1;

  # Set globals that should be per-channel
  $::Channel_URI=$uri;
  $::Channel_Title=$title;
  $::Channel_Listening=1;

  my $user_name=$uri->channel."-logger";

  my $conn = $::IRC->newconn(Nick    => $::Nick,
			     Server  => $uri->host,
			     Port    => $uri->port,
			     Ircname => $::IRC_Name,
			     Username => $user_name,
			     LocalAddr => $::Host);

  die "$::program: Cannot create connection to $uri\n" 
    unless $conn;

  # Install handlers
  # On 'end of MOTD' event, join ilrt channel
  $conn->add_global_handler(376, \&on_connect);
  $conn->add_global_handler(353, \&on_names);
  $conn->add_global_handler('disconnect', \&on_disconnect);

  $conn->add_handler('msg', \&on_msg);
  $conn->add_handler('public', \&on_public);
  $conn->add_handler('part', \&on_part);
  $conn->add_handler('join', \&on_join);
  $conn->add_handler('kick', \&on_disconnect);
  $conn->add_handler('caction', \&on_caction);
  $conn->add_handler('quit', \&on_quit);
  $conn->add_handler('nick', \&on_nick);
  $conn->add_handler('nicknameinuse', \&on_nicknameinuse);
  $conn->add_handler('topic', \&on_topic);
  $conn->add_handler('notice', \&on_notice);

}
