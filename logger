#!/usr/bin/perl -w
#
# IRC chat logger
#
# $Source$
# $Id$
#
# (C) Copyright 2000 Dave Beckett, ILRT, University of Bristol
# http://www.ilrt.bristol.ac.uk/people/cmdjb/
#

use URI;

use Net::IRC;
use File::Path;
use File::Basename;

my $Nick='logger';
my $IRC_Name='Chat Logger';
my $Max_Results=5;
my @Month_names = qw/XXX Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/;

%ENV=();
$ENV{PATH}='/bin:/usr/bin:/usr/local/bin';

######################################################################
package URI::irc;

# http://www.w3.org/Addressing/draft-mirashi-url-irc-01.txt
# irc:[ //[ <host>[:<port>] ]/[<target>] [,needpass] ]

require URI::_server;

@ISA=qw(URI::_server);

sub default_port { 6667 }

sub channel ($) {
  my $path=shift->path;
  if($path && $path =~ m%^/([^/]+)%) {
    return $1;
  }
  undef;
}

package main;

sub xml_escape ($) {
  my $string=shift;
  $string =~ s/\&/\&amp;/g;
  $string =~ s/</\&lt;/g;
  $string =~ s/>/\&gt;/g;
  $string;
}

######################################################################

$::program=basename $0;

$::ARGS="$0 @ARGV";

die "Usage: $program irc://host[:port]/channel,isnick,needpass log-dir\n"
  unless @ARGV==2;
my($uri_string,$log_root)=@ARGV;


my $uri;
eval '$uri=new URI $uri_string';
die "$program: '$uri_string' does not look like an IRC URI\n" if ($@ || !$uri);

die "$program: log dir $log_root does not exist\n" unless -d $log_root;

my $Channel='#'.$uri->channel;
my $Server=$uri->host;
my $Port=$uri->port;
my $Log_Root=$log_root;


my $host;
if(`uname -n` =~ /^([-\w.]+)$/) {
  $host=$1;
} else {
  $host='unknown';
}


my $irc = new Net::IRC;
my $conn = $irc->newconn(Nick    => $Nick,
			 Server  => $Server,
			 Port    => $Port,
			 Ircname => $IRC_Name,
			 LocalAddr => $host);
die "$program: Cannot create connection to $uri_string\n" unless $conn;

$::listening=1;
$::departing=0;


######################################################################
# Logging

sub log_event ($$;$) {
  my($t, $msg, $nick)=@_;

  return if !$::listening;

  my $c=$Channel;
  $c=~ s/\W//g;
  my $log_dir="$Log_Root/$Server:$Port/$c/";

  mkpath([$log_dir], 0, 0755) if ! -d $log_dir;
  # Failed!
  if (! -d $log_dir) {
    $conn->privmsg($Channel, "failed to create chat log dir, quitting");
    exit(0);
  }

  my @tm = gmtime($t);
  $tm[5]+= 1900; $tm[4]++;
  my $date = sprintf("%04d-%02d-%02d", $tm[5], $tm[4], $tm[3]);
  my $time = sprintf("%02d:%02d:%02d", $tm[2], $tm[1], $tm[0]);
  my $date_time="$date $time";

  my $log_file = "$log_dir/$date.txt";
  my $rdf_log_file = "$log_dir/$date.rdf";

  my $rdf_suffix="  </rdf:Seq>\n</rdf:Description>\n</rdf:RDF>\n";


  # Failed!
  if (!open(LOG, ">>$log_file")) {
    $conn->privmsg($Channel, "failed to append to log file, quitting - $!");
    exit(0);
  }
  my $text_msg=$nick ? qq{<$nick> $msg} : $msg;
  print LOG "$time $text_msg\n";
  close(LOG);


  if(!-r $rdf_log_file) {
    if (!open(RLOG, ">$rdf_log_file")) {
      $conn->privmsg($Channel, "failed to append to log file, quitting - $!");
      exit(0);
    }

    print RLOG <<"EOT";
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:foaf="http://xmlns.com/foaf/0.1/">
<rdf:Description rdf:about="$uri_string">
  <rdf:Seq>
EOT
  } else {
    if (!open(RLOG, "+<$rdf_log_file")) {
      $conn->privmsg($Channel, "failed to append to log file, quitting - $!");
      exit(0);
    }

    # seek back
    seek(RLOG, -length($rdf_suffix), 2) # 2= SEEK_END
  }

  print RLOG <<"EOT";
    <rdf:li rdf:parseType="Resource">
      <dc:date>${date}T$time</dc:date>
EOT
  print RLOG qq{      <dc:description>}.xml_escape($msg).qq{</dc:description>\n};
  print RLOG qq{      <foaf:nick>$nick</foaf:nick>\n} if $nick;
  print RLOG qq{    </rdf:li>\n};
  print RLOG $rdf_suffix;

  close(RLOG);
}


sub get_logs () {
  my $c=$Channel;
  $c=~ s/\W//g;
  my $log_dir="$Log_Root/$Server:$Port/$c/";

  return () if !opendir(DIR, $log_dir);

  # In date order, newest lines at top
  my(@results)=();
  # Newest files first
  for my $file (reverse sort readdir(DIR)) {
    next unless $file =~ /^\d\d\d\d-\d\d.log/;
    open(LOG, "$log_dir/$file") or next;
    
    # Append to list, reverse date sorted list - i.e. older entries at end 
    my(@lines);
    while(<LOG>) {
      chomp;
      # Ignore logger's own output
      next if m%^\d\d:\d\d:\d\d <$Nick>%;
      push(@lines, $_) if length $_;
    };
    close(LOG);
    push(@results, reverse @lines);
  }
  closedir(DIR);

  return(@results);
}


######################################################################
# Global events

# What to do when logger successfully connects.
sub on_connect {
  my ($self, $event) = @_;
  
  $self->join($Channel);
  $::listening=1;
  $conn->me($Channel, ' is listening');
}


# Prints the names of people in a channel when we enter.
sub on_names {
  my ($self, $event) = @_;
  my (@list, $channel) = ($event->args);
  
  # splice() only works on real arrays. Sigh.
  ($channel, @list) = splice @list, 2;
  
  log_event(time, "Users on $channel: @list");
}


# Reconnect to the server when we die.
sub on_disconnect {
  my ($self, $event) = @_;
  
  log_event(time, "Disconnected from ". $event->from(). " (". ($event->args())[0]. ")");

  return if $::departing;

  log_event(time, "Attempting to reconnect");
  sleep(1);
  $self->connect();
}


######################################################################
# Per connection events


# When received a private message
sub on_msg {
  my($self,$event)=@_;
  my $nick = $event->nick;
  
  my $arg = join(' ', $event->args);
  command_for_me($self, $nick, $arg, 1);
}


# What to do when we receive channel text.
sub on_public {
  my ($self, $event) = @_;
  my @to = $event->to;
  my ($nick, $mynick) = ($event->nick, $self->nick);
  my $arg = join(' ', $event->args);

  # Private stuff
  return if $arg =~ /^\[off\]/i;

  if ($arg =~ /^$mynick,\s+(.*)$/) {
    command_for_me($self, $nick, $1, 0);
  }

  log_event(time, $arg, $nick);
}


# What to do when we receive /me (and other stuff??)
sub on_caction {
  my ($self, $event) = @_;
  my $nick = $event->nick;
  my $arg = join(' ', $event->args);

  # Private stuff
  return if $arg =~ /^\[off\]/i;

  log_event(time, "$nick $arg", $nick);
}


# What to do when someone leaves a channel logger is on.
sub on_part {
  my ($self, $event) = @_;
  my ($channel) = ($event->to)[0];
  
  log_event(time, "left channel", $event->nick);
}


# What to do when someone joins a channel logger is on.
sub on_join {
  my ($self, $event) = @_;
  my ($channel) = ($event->to)[0];
  my $user_nick=$event->nick;

  log_event(time, sprintf("%s (%s) has joined channel", $user_nick, $event->userhost), $user_nick);

  my $output="Hello $user_nick, I may be recording you.  At present ";
  if(!$::listening) {
    $output.="I'm not listening.";
  } else {
    $output.="I'm listening.";
  }

  $conn->notice($event->nick, $output);
}


sub command_for_me ($$$$) {
  my($self, $from_nick, $command, $is_private)=@_;

  $command=~s/^\s+//;

  my $output='';

  my $dest_nick=($is_private ? $from_nick : $Channel);


  if($is_private && $command eq 'restart') {
    $::departing=1;
    $conn->me($Channel, ' is departing');
    $conn->quit;
    exec $ARGS;
  }
  
  if($command=~ /^(?:quit|finish|terminate|die die die|exterminate)/i) {
    $::departing=1;
    $conn->me($Channel, ' is departing');
    $conn->quit;
    exit 0;
  }
  
  if($command=~ /^(?:be quiet|shut up|silence|sshush|stop)/i) {
    if($::listening) {
      $conn->me($Channel, ' is not listening');
      $::listening=0;
    } else {
      $conn->me($Channel, ' is already not listening');
    }
    return;
  }
  
  if($command=~ /^(?:hello|listen|record|start|begin)/i) {
    if(!$::listening) {
      $conn->me($Channel, ' is listening');
      $::listening=1;
    } else {
      $conn->me($Channel, ' is already listening');
    }
    return;
  }

  if(!$::listening) {
    $output="I'm not listening. ";
  } else {
    $output="I'm listening. ";
  }

  # Allow question?
  if ($command =~ /^(.+)\?$/) {
    $command="grep $1";
  }

  if($command=~ /^help/i) {
    $output.=q{I understand 'quit', 'silence', 'listen', 'grep [-i] [first-last|last] <perl regex>.  I also respond to private messages.'};
  }
  elsif ($command =~ /^(?:grep|search for|find)\s+(.+)$/) {
    my $search=$1;
    my $flags='';
    my($first,$last)=(0,$Max_Results);

    if($search=~ s/^-i\s+//) {
      $flags='(?i)';
    }
    if($search=~ s/^(\d+|\d+-\d+)\s+(?:things about\s+|)//) {
      my $arg=$1;
      if($arg=~ m%^(\d+)-(\d+)$%) {
	($first,$last)=($1,$2);
	# Reset if stupid things done
	if($first > $last) {
	  ($first,$last)=(0,$Max_Results);
	}
      } else {
        $last=$arg;
      }
    }

    my $orig_search=$search;

    # Only allow a few regexes

    # Remove (?...) blocks since they can do evals
    $search =~ s/\(\?[^)]+\)//g;
    # Remove variable references
    $search =~ s/\$//g;
    # Quote '/'s
    $search =~ s%/%\\/%g;


    # Prefix with flags
    $search=$flags.$search;

    my(@results);
    eval "\@results=grep(/$search/, get_logs())";
    if($!) {
      @results=();
      my $msg=$!; $msg=~ s/^ at .+$//;
      $output.=qq{ Sorry, search failed with error - $msg};
    } elsif (!@results) {
      $output.=qq{ Sorry, nothing found for '$orig_search'};
      $output.=qq{ (internally: "$search")} if $orig_search ne $search;
    } else {
      my $pl=(@results != 1) ? 's' : '';
      $output.=" I found ".scalar(@results)." answer$pl";
      $last=@results if $last > @results;
      if($first !=0 || $last != @results) {
	$output.=" (showing $first...$last)";
      }
      $conn->notice($dest_nick, $output);
      log_event(time, $output, $Nick) unless $is_private;

      sleep(1);
      for(my $i=$first; ($i< @results) && ($i <= $last); $i++) {
	$output="$i) ".$results[$i];
	$conn->notice($dest_nick, $output);
	log_event(time, $output, $Nick) unless $is_private;
	sleep(1);
      }
      return;
    }
  } else {
    $output.="I don't understand that, $from_nick";
  }

  $conn->notice($dest_nick, $output);
  log_event(time, $output, $Nick) unless $is_private;
}



# Install handlers
# On 'end of MOTD' event, join ilrt channel
$conn->add_global_handler(376, \&on_connect);
$conn->add_global_handler(353, \&on_names);
$conn->add_global_handler('disconnect', \&on_disconnect);

$conn->add_handler('msg', \&on_msg);
$conn->add_handler('public', \&on_public);
$conn->add_handler('part', \&on_part);
$conn->add_handler('join', \&on_join);
$conn->add_handler('kick', \&on_disconnect);
$conn->add_handler('caction', \&on_caction);


$irc->start;


exit 0;

